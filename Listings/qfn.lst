C51 COMPILER V9.54   QFN                                                                   02/25/2018 00:50:20 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE QFN
OBJECT MODULE PLACED IN .\Objects\qfn.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\qpn\src\qfn\qfn.c OPTIMIZE(8,SPEED) BROWSE INCDIR(Y:\c51\qpn\include;
                    -Y:\c51\C51_lib) DEBUG OBJECTEXTEND PRINT(.\Listings\qfn.lst) TABS(2) OBJECT(.\Objects\qfn.obj)

line level    source

   1          /**
   2          * @file
   3          * @brief QF-nano implementation.
   4          * @ingroup qfn
   5          * @cond
   6          ******************************************************************************
   7          * Last updated for version 6.1.1
   8          * Last updated on  2018-02-18
   9          *
  10          *                    Q u a n t u m     L e a P s
  11          *                    ---------------------------
  12          *                    innovating embedded systems
  13          *
  14          * Copyright (C) Quantum Leaps, LLC. All rights reserved.
  15          *
  16          * This program is open source software: you can redistribute it and/or
  17          * modify it under the terms of the GNU General Public License as published
  18          * by the Free Software Foundation, either version 3 of the License, or
  19          * (at your option) any later version.
  20          *
  21          * Alternatively, this program may be distributed and modified under the
  22          * terms of Quantum Leaps commercial licenses, which expressly supersede
  23          * the GNU General Public License and are specifically designed for
  24          * licensees interested in retaining the proprietary status of their code.
  25          *
  26          * This program is distributed in the hope that it will be useful,
  27          * but WITHOUT ANY WARRANTY; without even the implied warranty of
  28          * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  29          * GNU General Public License for more details.
  30          *
  31          * You should have received a copy of the GNU General Public License
  32          * along with this program. If not, see <http://www.gnu.org/licenses/>.
  33          *
  34          * Contact information:
  35          * https://www.state-machine.com
  36          * mailto:info@state-machine.com
  37          ******************************************************************************
  38          * @endcond
  39          */
  40          #include "qpn_conf.h" /* QP-nano configuration file (from the application) */
  41          #include "qfn_port.h" /* QF-nano port from the port directory */
  42          #include "qassert.h"  /* embedded systems-friendly assertions */
  43          
  44          Q_DEFINE_THIS_MODULE("qfn")
  45          
  46          /* Global-scope objects *****************************************************/
  47          
  48          /**
  49          * @description
  50          * This variable stores the number of active objects in the application.
  51          * This is the number of elements (dimension of) the QF_active[] array.
  52          */
  53          uint_fast8_t QF_maxActive_;
  54          
C51 COMPILER V9.54   QFN                                                                   02/25/2018 00:50:20 PAGE 2   

  55          /**
  56          * @description
  57          * The QF-nano ready set keeps track of active objects that are ready to run.
  58          * The ready set represents each active object as a bit, with the bits
  59          * assigned according to priorities of the active objects. The bit is set
  60          * if the corresponding active object is ready to run (i.e., has one or
  61          * more events in its event queue) and zero if the event queue is empty.
  62          * The QF-nano ready set is one byte-wide, which corresponds to 8 active
  63          * objects maximum.
  64          */
  65          uint_fast8_t volatile QF_readySet_;
  66          
  67          #ifdef QF_TIMEEVT_USAGE
  68          /**
  69          * @description
  70          * The QF-nano timer set keeps track of the armed time events. The timer set
  71          * represents the timeout down-counter of each active object as a bit, with
  72          * the bits assigned according to priorities of the active objects. The bit
  73          * is set if the corresponding timeout down-counter is not zero (i.e., is
  74          * counting down) and zero if the down-counter is zero. The QF-nano time event
  75          * set is one byte-wide, which corresponds to 8 active objects maximum.@n
  76          * @n
  77          * The main use of the QF_timerSetX_ is to quickly determine that all time
  78          * events are disarmed by testing (QF_timerSetX_[tickRate] == 0).
  79          * If so, the CPU can go to longer sleep mode, in which the system clock
  80          * tick ISR is turned off.
  81          *
  82          * @note The test (QF_timerSet_[tickRate] == 0) must be always performed
  83          * inside a CRITICAL SECTION.
  84          */
  85          uint_fast8_t volatile QF_timerSetX_[QF_MAX_TICK_RATE];
  86          #endif
  87          
  88          #ifndef QF_LOG2
  89          uint8_t const Q_ROM QF_log2Lkup[16] = {
  90              (uint8_t)0, (uint8_t)1, (uint8_t)2, (uint8_t)2,
  91              (uint8_t)3, (uint8_t)3, (uint8_t)3, (uint8_t)3,
  92              (uint8_t)4, (uint8_t)4, (uint8_t)4, (uint8_t)4,
  93              (uint8_t)4, (uint8_t)4, (uint8_t)4, (uint8_t)4
  94          };
  95          #endif /* QF_LOG2 */
  96          
  97          /****************************************************************************/
  98          void QActive_ctor(QActive * const me, QStateHandler initial) {
  99   1          static QActiveVtbl const vtbl = { /* QActive virtual table */
 100   1              { &QHsm_init_,
 101   1                &QHsm_dispatch_ },
 102   1              &QActive_postX_,
 103   1              &QActive_postXISR_
 104   1          };
 105   1      
 106   1          /**
 107   1          * @note QActive inherits QActive, so by the @ref oop convention
 108   1          * it should call the constructor of the superclass, i.e., QActive_ctor().
 109   1          * However, this would pull in the QActiveVtbl, which in turn will pull
 110   1          * in the code for QHsm_init_() and QHsm_dispatch_() implemetations,
 111   1          * which is expensive. To avoid this code size penalty, in case ::QHsm is
 112   1          * not used in a given project, the call to QHsm_ctor() avoids pulling
 113   1          * in the code for QHsm.
 114   1          */
 115   1          QHsm_ctor(&me->super, initial);
 116   1          me->super.vptr = &vtbl.super; /* hook the vptr to QActive virtual table */
C51 COMPILER V9.54   QFN                                                                   02/25/2018 00:50:20 PAGE 3   

 117   1      }
 118          
 119          /****************************************************************************/
 120          /**
 121          * @description
 122          * Direct event posting is the simplest asynchronous communication method
 123          * available in QF-nano.
 124          *
 125          * @attention
 126          * This function should be called only via the macro QACTIVE_POST()
 127          * or QACTIVE_POST_X(). This function should be only used in the
 128          * __task__ context.
 129          *
 130          * @param[in,out] me     pointer (see @ref oop)
 131          * @param[in]     margin number of required free slots in the queue after
 132          *                       posting the event. The special value #QF_NO_MARGIN
 133          *                       means that this function will assert if posting fails.
 134          * @param[in]     sig    signal of the event to be posted
 135          * @param[in]     par    parameter of the event to be posted
 136          *
 137          * @usage
 138          * @include qfn_postx.c
 139          */
 140          #if (Q_PARAM_SIZE != 0)
 141          bool QActive_postX_(QActive * const me, uint_fast8_t margin,
 142                              enum_t const sig, QParam const par)
 143          #else
              bool QActive_postX_(QActive * const me, uint_fast8_t margin,
                                  enum_t const sig)
              #endif
 147          {
 148   1          QActiveCB const Q_ROM *acb = &QF_active[me->prio];
 149   1          uint_fast8_t qlen = (uint_fast8_t)Q_ROM_BYTE(acb->qlen);
 150   1      
 151   1          QF_INT_DISABLE();
 152   1      
 153   1          if (margin == QF_NO_MARGIN) {
 154   2              if (qlen > (uint_fast8_t)me->nUsed) {
 155   3                  margin = (uint_fast8_t)true; /* can post */
 156   3              }
 157   2              else {
 158   3                  margin = (uint_fast8_t)false; /* cannot post */
 159   3                  Q_ERROR_ID(310); /* must be able to post the event */
 160   3              }
 161   2          }
 162   1          else if ((qlen - (uint_fast8_t)me->nUsed) > margin) {
 163   2              margin = (uint_fast8_t)true; /* can post */
 164   2          }
 165   1          else {
 166   2              margin = (uint_fast8_t)false; /* cannot post */
 167   2          }
 168   1      
 169   1          if (margin) { /* can post the event? */
 170   2              /* insert event into the ring buffer (FIFO) */
 171   2              QF_ROM_QUEUE_AT_(acb, me->head).sig = (QSignal)sig;
 172   2      #if (Q_PARAM_SIZE != 0)
 173   2              QF_ROM_QUEUE_AT_(acb, me->head).par = par;
 174   2      #endif
 175   2              if (me->head == (uint8_t)0) {
 176   3                  me->head = (uint8_t)qlen; /* wrap the head */
 177   3              }
 178   2              --me->head;
C51 COMPILER V9.54   QFN                                                                   02/25/2018 00:50:20 PAGE 4   

 179   2              ++me->nUsed;
 180   2      
 181   2              /* is this the first event? */
 182   2              if (me->nUsed == (uint8_t)1) {
 183   3      
 184   3                  /* set the corresponding bit in the ready set */
 185   3                  QF_readySet_ |= (uint_fast8_t)
 186   3                      ((uint_fast8_t)1 << (me->prio - (uint8_t)1));
 187   3      
 188   3      #ifdef qkn_h
                          if (QK_sched_() != (uint_fast8_t)0) {
                              QK_activate_(); /* activate the next active object */
                          }
              #endif
 193   3              }
 194   2          }
 195   1          QF_INT_ENABLE();
 196   1      
 197   1          return (bool)margin;
 198   1      }
 199          
 200          /****************************************************************************/
 201          /**
 202          * @description
 203          * Direct event posting is the simplest asynchronous communication method
 204          * available in QF-nano.
 205          *
 206          * @attention
 207          * This function should be called only via the macro QACTIVE_POST_ISR()
 208          * or QACTIVE_POST_X_ISR(). This function should be only used in the
 209          * __ISR__ context.
 210          *
 211          * @param[in,out] me     pointer (see @ref oop)
 212          * @param[in]     margin number of required free slots in the queue after
 213          *                       posting the event. The special value #QF_NO_MARGIN
 214          *                       means that this function will assert if posting fails.
 215          * @param[in]     sig    signal of the event to be posted
 216          * @param[in]     par    parameter of the event to be posted
 217          *
 218          * @usage
 219          * @include qfn_postx.c
 220          */
 221          #if (Q_PARAM_SIZE != 0)
 222          bool QActive_postXISR_(QActive * const me, uint_fast8_t margin,
 223                                 enum_t const sig, QParam const par)
 224          #else
              bool QActive_postXISR_(QActive * const me, uint_fast8_t margin,
                                     enum_t const sig)
              #endif
 228          {
 229   1      #ifdef QF_ISR_NEST
              #ifdef QF_ISR_STAT_TYPE
                  QF_ISR_STAT_TYPE stat;
              #endif
              #endif
 234   1          QActiveCB const Q_ROM *acb = &QF_active[me->prio];
 235   1          uint_fast8_t qlen = (uint_fast8_t)Q_ROM_BYTE(acb->qlen);
 236   1      
 237   1      #ifdef QF_ISR_NEST
              #ifdef QF_ISR_STAT_TYPE
                  QF_ISR_DISABLE(stat);
              #else
C51 COMPILER V9.54   QFN                                                                   02/25/2018 00:50:20 PAGE 5   

                  QF_INT_DISABLE();
              #endif
              #endif
 244   1      
 245   1          if (margin == QF_NO_MARGIN) {
 246   2              if (qlen > (uint_fast8_t)me->nUsed) {
 247   3                  margin = (uint_fast8_t)true; /* can post */
 248   3              }
 249   2              else {
 250   3                  margin = (uint_fast8_t)false; /* cannot post */
 251   3                  Q_ERROR_ID(310); /* must be able to post the event */
 252   3              }
 253   2          }
 254   1          else if ((qlen - (uint_fast8_t)me->nUsed) > margin) {
 255   2              margin = (uint_fast8_t)true; /* can post */
 256   2          }
 257   1          else {
 258   2              margin = (uint_fast8_t)false; /* cannot post */
 259   2          }
 260   1      
 261   1          if (margin) { /* can post the event? */
 262   2              /* insert event into the ring buffer (FIFO) */
 263   2              QF_ROM_QUEUE_AT_(acb, me->head).sig = (QSignal)sig;
 264   2      #if (Q_PARAM_SIZE != 0)
 265   2              QF_ROM_QUEUE_AT_(acb, me->head).par = par;
 266   2      #endif
 267   2              if (me->head == (uint8_t)0) {
 268   3                  me->head = (uint8_t)qlen; /* wrap the head */
 269   3              }
 270   2              --me->head;
 271   2              ++me->nUsed;
 272   2              /* is this the first event? */
 273   2              if (me->nUsed == (uint8_t)1) {
 274   3                  /* set the bit */
 275   3                  QF_readySet_ |= (uint_fast8_t)
 276   3                      ((uint_fast8_t)1 << (me->prio - (uint8_t)1));
 277   3              }
 278   2          }
 279   1      
 280   1      #ifdef QF_ISR_NEST
              #ifdef QF_ISR_STAT_TYPE
                  QF_ISR_RESTORE(stat);
              #else
                  QF_INT_ENABLE();
              #endif
              #endif
 287   1      
 288   1          return (bool)margin;
 289   1      }
 290          
 291          /****************************************************************************/
 292          /**
 293          * @description
 294          * The function QF_init() initializes the number of active objects to be
 295          * managed by the framework and clears the internal QF-nano variables as well
 296          * as all registered active objects to zero, which is needed in case when
 297          * the startup code does not clear the uninitialized data (in violation of
 298          * the C Standard).
 299          *
 300          * @note
 301          * The intended use of the function is to call as follows:
 302          * QF_init(Q_DIM(QF_active));
C51 COMPILER V9.54   QFN                                                                   02/25/2018 00:50:20 PAGE 6   

 303          */
 304          void QF_init(uint_fast8_t maxActive) {
 305   1          QActive *a;
 306   1          uint_fast8_t p;
 307   1          uint_fast8_t n;
 308   1      
 309   1          /** @pre the number of active objects must be in range */
 310   1          Q_REQUIRE_ID(100, ((uint_fast8_t)1 < maxActive)
 311   1                            && (maxActive <= (uint_fast8_t)9));
*** WARNING C275 IN LINE 311 OF ..\qpn\src\qfn\qfn.c: expression with possibly no effect
 312   1          QF_maxActive_ = (uint_fast8_t)maxActive - (uint_fast8_t)1;
 313   1      
 314   1      #ifdef QF_TIMEEVT_USAGE
 315   1          for (n = (uint_fast8_t)0; n < (uint_fast8_t)QF_MAX_TICK_RATE; ++n) {
 316   2              QF_timerSetX_[n] = (uint_fast8_t)0;
 317   2          }
 318   1      #endif /* QF_TIMEEVT_USAGE */
 319   1      
 320   1          QF_readySet_ = (uint_fast8_t)0;
 321   1      
 322   1      #ifdef qkn_h
                  QK_attr_.actPrio = (uint_fast8_t)8; /* QK-nano scheduler locked */
              
              #ifdef QF_ISR_NEST
                  QK_attr_.intNest = (uint_fast8_t)0;
              #endif
              
              #ifdef QK_SCHED_LOCK
                  QK_attr_.lockPrio   = (uint_fast8_t)0;
                  QK_attr_.lockHolder = (uint_fast8_t)0;
              #endif
              
              #endif /* #ifdef qkn_h */
 335   1      
 336   1          /* clear all registered active objects... */
 337   1          for (p = (uint_fast8_t)1; p <= QF_maxActive_; ++p) {
 338   2              a = QF_ROM_ACTIVE_GET_(p);
 339   2      
 340   2              /* QF_active[p] must be initialized */
 341   2              Q_ASSERT_ID(110, a != (QActive *)0);
*** WARNING C275 IN LINE 341 OF ..\qpn\src\qfn\qfn.c: expression with possibly no effect
 342   2      
 343   2              a->head    = (uint8_t)0;
 344   2              a->tail    = (uint8_t)0;
 345   2              a->nUsed   = (uint8_t)0;
 346   2      #if (QF_TIMEEVT_CTR_SIZE != 0)
 347   2              for (n = (uint_fast8_t)0; n < (uint_fast8_t)QF_MAX_TICK_RATE; ++n) {
 348   3                  a->tickCtr[n].nTicks   = (QTimeEvtCtr)0;
 349   3      #ifdef QF_TIMEEVT_PERIODIC
 350   3                  a->tickCtr[n].interval = (QTimeEvtCtr)0;
 351   3      #endif /* def QF_TIMEEVT_PERIODIC */
 352   3              }
 353   2      #endif /* (QF_TIMEEVT_CTR_SIZE != 0) */
 354   2          }
 355   1      
 356   1      #ifdef QV_INIT /* initialization of the QV-nano kernel defined? */
                  QV_INIT(); /* port-specific initialization of the QV-nano kernel */
              #elif defined QK_INIT /* initialization of the QK-nano kernel defined? */
                  QK_INIT(); /* port-specific initialization of the QK-nano kernel */
              #endif
 361   1      }
 362          
C51 COMPILER V9.54   QFN                                                                   02/25/2018 00:50:20 PAGE 7   

 363          /****************************************************************************/
 364          /****************************************************************************/
 365          #if (QF_TIMEEVT_CTR_SIZE != 0)
 366          
 367          /****************************************************************************/
 368          /**
 369          * @description
 370          * This function must be called periodically from a time-tick ISR or from
 371          * an ISR so that QF-nano can manage the timeout events assigned to the given
 372          * system clock tick rate.
 373          *
 374          * @param[in]  tickRate  system clock tick rate serviced in this call.
 375          *
 376          * @note Each system tick rate posts timeout events with a different signal
 377          * as follows:@n
 378          * tickRate==0  Q_TIMEOUT_SIG@n
 379          * tickRate==1  Q_TIMEOUT1_SIG@n
 380          * tickRate==2  Q_TIMEOUT2_SIG@n
 381          * tickRate==3  Q_TIMEOUT3_SIG
 382          *
 383          * @note The calls to QF_tickXISR() with different tick rate parameter can
 384          * preempt each other. For example, higher clock tick rates might be serviced
 385          * from interrupts that can preempt lower-priority interrupts.
 386          */
 387          void QF_tickXISR(uint_fast8_t const tickRate) {
 388   1          uint_fast8_t p = QF_maxActive_;
 389   1          do {
 390   2              QActive *a = QF_ROM_ACTIVE_GET_(p);
 391   2              QTimer *t = &a->tickCtr[tickRate];
 392   2      
 393   2              if (t->nTicks != (QTimeEvtCtr)0) {
 394   3                  --t->nTicks;
 395   3                  if (t->nTicks == (QTimeEvtCtr)0) {
 396   4      
 397   4      #ifdef QF_TIMEEVT_PERIODIC
 398   4                      if (t->interval != (QTimeEvtCtr)0) {
 399   5                          t->nTicks = t->interval; /* re-arm the periodic timer */
 400   5                      }
 401   4      #endif /* QF_TIMEEVT_PERIODIC */
 402   4      
 403   4      #ifdef QF_TIMEEVT_USAGE
 404   4                      QF_timerSetX_[tickRate] &= (uint_fast8_t)
 405   4                          ~((uint_fast8_t)1 << (p - (uint_fast8_t)1));
 406   4      #endif /* QF_TIMEEVT_USAGE */
 407   4      
 408   4      #if (Q_PARAM_SIZE != 0)
 409   4                      QACTIVE_POST_ISR(a, (enum_t)Q_TIMEOUT_SIG + (enum_t)tickRate,
 410   4                                       (QParam)0);
*** ERROR C212 IN LINE 410 OF ..\qpn\src\qfn\qfn.c: indirect call: parameters do not fit within registers
 411   4      #else
                              QACTIVE_POST_ISR(a, (enum_t)Q_TIMEOUT_SIG + (enum_t)tickRate);
              #endif /* (Q_PARAM_SIZE != 0) */
 414   4                  }
 415   3              }
 416   2              --p;
 417   2          } while (p != (uint_fast8_t)0);
 418   1      }
 419          
 420          /****************************************************************************/
 421          /**
 422          * @description
 423          * Arms a time event to fire in a specified number of clock ticks at the
C51 COMPILER V9.54   QFN                                                                   02/25/2018 00:50:20 PAGE 8   

 424          * specified tick rate. The timeout signal gets directly posted (using the
 425          * FIFO policy) into the event queue of the active object calling this
 426          * function.
 427          *
 428          * @param[in,out] me       pointer (see @ref oop)
 429          * @param[in]     tickRate tick rate .
 430          * @param[in]     nTicks   number of clock ticks (at the associated rate)
 431          *                         to rearm the time event with.
 432          *
 433          * @note Each system tick rate posts timeout events with a different signal
 434          * as follows:@n
 435          * tickRate==0  Q_TIMEOUT_SIG@n
 436          * tickRate==1  Q_TIMEOUT1_SIG@n
 437          * tickRate==2  Q_TIMEOUT2_SIG@n
 438          * tickRate==3  Q_TIMEOUT3_SIG
 439          *
 440          * @note After posting, a one-shot time event gets automatically disarmed.
 441          *
 442          * @note A time event can be disarmed at any time by calling the
 443          * QActive_disarmX() function.
 444          *
 445          * @usage
 446          * The following example shows how to arm a time event from a state
 447          * machine of an active object:
 448          * @include qfn_armx.c
 449          */
 450          #ifdef QF_TIMEEVT_PERIODIC
 451          void QActive_armX(QActive * const me, uint_fast8_t const tickRate,
 452                            QTimeEvtCtr const nTicks, QTimeEvtCtr const interval)
 453          #else
              void QActive_armX(QActive * const me, uint_fast8_t const tickRate,
                                QTimeEvtCtr const nTicks)
              #endif
 457          {
 458   1          QF_INT_DISABLE();
 459   1          me->tickCtr[tickRate].nTicks = nTicks;
 460   1      #ifdef QF_TIMEEVT_PERIODIC
 461   1          me->tickCtr[tickRate].interval = interval;
 462   1      #endif /* QF_TIMEEVT_PERIODIC */
 463   1      
 464   1      #ifdef QF_TIMEEVT_USAGE
 465   1          /* set a bit in QF_timerSetX_[] to rememer that the timer is running */
 466   1          QF_timerSetX_[tickRate] |= (uint_fast8_t)
 467   1              ((uint_fast8_t)1 << (me->prio - (uint8_t)1));
 468   1      #endif
 469   1          QF_INT_ENABLE();
 470   1      }
 471          
 472          /****************************************************************************/
 473          /**
 474          * @description
 475          * The time event of the active object gets disarmed (stopped).
 476          *
 477          * @param[in,out] me       pointer (see @ref oop)
 478          * @param[in]     tickRate tick rate
 479          *
 480          * @note You should __not__ assume that the timeout event will not
 481          * arrive after you disarm the time event. The timeout event could be
 482          * already in the event queue.
 483          */
 484          void QActive_disarmX(QActive * const me, uint_fast8_t const tickRate) {
 485   1          QF_INT_DISABLE();
C51 COMPILER V9.54   QFN                                                                   02/25/2018 00:50:20 PAGE 9   

 486   1          me->tickCtr[tickRate].nTicks = (QTimeEvtCtr)0;
 487   1      #ifdef QF_TIMEEVT_PERIODIC
 488   1          me->tickCtr[tickRate].interval = (QTimeEvtCtr)0;
 489   1      #endif /* QF_TIMEEVT_PERIODIC */
 490   1      
 491   1      #ifdef QF_TIMEEVT_USAGE
 492   1          /* clear a bit in QF_timerSetX_[] to rememer that timer is not running */
 493   1          QF_timerSetX_[tickRate] &= (uint_fast8_t)
 494   1              ~((uint_fast8_t)1 << (me->prio - (uint8_t)1));
 495   1      #endif
 496   1          QF_INT_ENABLE();
 497   1      }
 498          #endif /* #if (QF_TIMEEVT_CTR_SIZE != 0) */

C51 COMPILATION COMPLETE.  2 WARNING(S),  1 ERROR(S)
