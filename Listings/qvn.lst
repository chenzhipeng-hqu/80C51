C51 COMPILER V9.54   QVN                                                                   02/25/2018 00:49:24 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE QVN
OBJECT MODULE PLACED IN .\Objects\qvn.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\qpn\src\qvn\qvn.c OPTIMIZE(8,SPEED) BROWSE INCDIR(Y:\c51\qpn\include;
                    -Y:\c51\C51_lib) DEBUG OBJECTEXTEND PRINT(.\Listings\qvn.lst) TABS(2) OBJECT(.\Objects\qvn.obj)

line level    source

   1          /**
   2          * @file
   3          * @brief QV-nano implementation.
   4          * @ingroup qvn
   5          * @cond
   6          ******************************************************************************
   7          * Last updated for version 6.1.1
   8          * Last updated on  2018-02-18
   9          *
  10          *                    Q u a n t u m     L e a P s
  11          *                    ---------------------------
  12          *                    innovating embedded systems
  13          *
  14          * Copyright (C) Quantum Leaps, LLC. All rights reserved.
  15          *
  16          * This program is open source software: you can redistribute it and/or
  17          * modify it under the terms of the GNU General Public License as published
  18          * by the Free Software Foundation, either version 3 of the License, or
  19          * (at your option) any later version.
  20          *
  21          * Alternatively, this program may be distributed and modified under the
  22          * terms of Quantum Leaps commercial licenses, which expressly supersede
  23          * the GNU General Public License and are specifically designed for
  24          * licensees interested in retaining the proprietary status of their code.
  25          *
  26          * This program is distributed in the hope that it will be useful,
  27          * but WITHOUT ANY WARRANTY; without even the implied warranty of
  28          * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  29          * GNU General Public License for more details.
  30          *
  31          * You should have received a copy of the GNU General Public License
  32          * along with this program. If not, see <http://www.gnu.org/licenses/>.
  33          *
  34          * Contact information:
  35          * https://www.state-machine.com
  36          * mailto:info@state-machine.com
  37          ******************************************************************************
  38          * @endcond
  39          */
  40          #include "qpn_conf.h" /* QP-nano configuration file (from the application) */
  41          #include "qfn_port.h" /* QF-nano port from the port directory */
  42          #include "qassert.h"  /* embedded systems-friendly assertions */
  43          
  44          Q_DEFINE_THIS_MODULE("qvn")
  45          
  46          /* protection against including this source file in a wrong project */
  47          #ifndef qvn_h
                  #error "Source file included in a project NOT based on the QV-nano kernel"
              #endif /* qvn_h */
  50          
  51          /****************************************************************************/
  52          /**
  53          * @description
  54          * QF_run() is typically called from your startup code after you initialize
C51 COMPILER V9.54   QVN                                                                   02/25/2018 00:49:24 PAGE 2   

  55          * the QF and start at least one active object with QActive_start().
  56          * This implementation of QF_run() is for the cooperative Vanilla kernel.
  57          *
  58          * @returns QF_run() typically does not return in embedded applications.
  59          * However, when QP runs on top of an operating system,  QF_run() might
  60          * return and in this case the return represents the error code (0 for
  61          * success). Typically the value returned from QF_run() is subsequently
  62          * passed on as return from main().
  63          */
  64          int_t QF_run(void) {
  65   1          uint_fast8_t p;
  66   1          QActive *a;
  67   1      
  68   1      #ifdef QF_MAX_ACTIVE /* deprecated constant provided? */
              #if (QF_MAX_ACTIVE < 1) || (8 < QF_MAX_ACTIVE)
                  #error "QF_MAX_ACTIVE not defined or out of range. Valid range is 1..8"
              #endif
                  QF_maxActive_ = (uint_fast8_t)QF_MAX_ACTIVE;
              #else
  74   1          /** @pre the number of active objects must be initialized by calling:
  75   1          * QF_init(Q_DIM(QF_active));
  76   1          */
  77   1          Q_REQUIRE_ID(100, ((uint_fast8_t)1 <= QF_maxActive_)
  78   1                            && (QF_maxActive_ <= (uint_fast8_t)8));
*** WARNING C275 IN LINE 78 OF ..\qpn\src\qvn\qvn.c: expression with possibly no effect
  79   1      #endif
  80   1      
  81   1          /* set priorities all registered active objects... */
  82   1          for (p = (uint_fast8_t)1; p <= QF_maxActive_; ++p) {
  83   2              a = QF_ROM_ACTIVE_GET_(p);
  84   2      
  85   2              /* QF_active[p] must be initialized */
  86   2              Q_ASSERT_ID(810, a != (QActive *)0);
*** WARNING C275 IN LINE 86 OF ..\qpn\src\qvn\qvn.c: expression with possibly no effect
  87   2      
  88   2              a->prio = (uint8_t)p; /* set the priority of the active object */
  89   2          }
  90   1      
  91   1          /* trigger initial transitions in all registered active objects... */
  92   1          for (p = (uint_fast8_t)1; p <= QF_maxActive_; ++p) {
  93   2              a = QF_ROM_ACTIVE_GET_(p);
  94   2              QHSM_INIT(&a->super); /* take the initial transition in the SM */
  95   2          }
  96   1      
  97   1          QF_onStartup(); /* invoke startup callback */
  98   1      
  99   1          /* the event loop of the cooperative QV-nano kernel... */
 100   1          QF_INT_DISABLE();
 101   1          for (;;) {
 102   2              if (QF_readySet_ != (uint_fast8_t)0) {
 103   3                  QActiveCB const Q_ROM *acb;
 104   3      
 105   3      #ifdef QF_LOG2
                          p = QF_LOG2(QF_readySet_);
              #else
 108   3                  /* hi nibble non-zero? */
 109   3                  if ((QF_readySet_ & (uint_fast8_t)0xF0) != (uint_fast8_t)0) {
 110   4                      p = (uint_fast8_t)(
 111   4                            (uint_fast8_t)Q_ROM_BYTE(QF_log2Lkup[QF_readySet_ >> 4])
 112   4                            + (uint_fast8_t)4);
 113   4                  }
 114   3                  else { /* hi nibble of QF_readySet_ is zero */
C51 COMPILER V9.54   QVN                                                                   02/25/2018 00:49:24 PAGE 3   

 115   4                      p = (uint_fast8_t)Q_ROM_BYTE(QF_log2Lkup[QF_readySet_]);
 116   4                  }
 117   3      #endif /* QF_LOG2 */
 118   3      
 119   3                  acb = &QF_active[p];
 120   3                  a = QF_ROM_ACTIVE_GET_(p);
 121   3      
 122   3                  /* some unsuded events must be available */
 123   3                  Q_ASSERT_ID(820, a->nUsed > (uint8_t)0);
*** WARNING C275 IN LINE 123 OF ..\qpn\src\qvn\qvn.c: expression with possibly no effect
 124   3      
 125   3                  --a->nUsed;
 126   3                  Q_SIG(a) = QF_ROM_QUEUE_AT_(acb, a->tail).sig;
 127   3      #if (Q_PARAM_SIZE != 0)
 128   3                  Q_PAR(a) = QF_ROM_QUEUE_AT_(acb, a->tail).par;
 129   3      #endif
 130   3                  if (a->tail == (uint8_t)0) { /* wrap around? */
 131   4                      a->tail = Q_ROM_BYTE(acb->qlen);
 132   4                  }
 133   3                  --a->tail;
 134   3                  QF_INT_ENABLE();
 135   3      
 136   3                  QHSM_DISPATCH(&a->super); /* dispatch to the HSM (RTC step) */
 137   3      
 138   3                  QF_INT_DISABLE();
 139   3                  /* empty queue? */
 140   3                  if (a->nUsed == (uint8_t)0) {
 141   4                      /* clear the bit corresponding to 'p' */
 142   4                      QF_readySet_ &=
 143   4                          (uint_fast8_t)~((uint_fast8_t)1 << (p - (uint_fast8_t)1));
 144   4                  }
 145   3              }
 146   2              else {
 147   3                  /* QV_onIdle() must be called with interrupts DISABLED because
 148   3                  * the determination of the idle condition (no events in the
 149   3                  * queues) can change at any time by an interrupt posting events
 150   3                  * to a queue. QV_onIdle() MUST enable interrupts internally,
 151   3                  * perhaps at the same time as putting the CPU into a power-saving
 152   3                  * mode.
 153   3                  */
 154   3                  QV_onIdle();
 155   3      
 156   3                  QF_INT_DISABLE();
 157   3              }
 158   2          }
 159   1      #ifdef __GNUC__  /* GNU compiler? */
                  return (int_t)0;
              #endif
 162   1      }
 163          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    505    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
